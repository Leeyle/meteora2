/**
 * ğŸŠ æ± çˆ¬è™«ç›‘æ§å™¨ - å®æ—¶ç›‘æ§æ± å‘ç°å’Œè¿‡æ»¤
 * ä½¿ç”¨Socket.IOè¿›è¡Œå®æ—¶é€šä¿¡
 */
class PoolCrawlerMonitor {
    constructor(container, options = {}) {
        this.container = typeof container === 'string' ? document.getElementById(container) : container;
        this.options = {
            autoConnect: true,
            reconnectInterval: 3000,
            maxReconnectAttempts: 5,
            ...options
        };

        // Socket.IOè¿æ¥
        this.socket = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;

        // æ± çˆ¬è™«æ•°æ®
        this.crawlerStatus = {
            isRunning: false,
            nextCrawlTime: null,
            lastCrawlTime: null,
            dailyDiscoveries: 0,
            totalDiscoveries: 0,
            qualifiedPools: 0,
            errorCount: 0
        };

        this.discoveredPools = new Map();
        this.qualifiedPools = new Map();
        this.crawlerConfig = null;

        // UIçŠ¶æ€
        this.isRendered = false;
        this.lastUpdateTime = null;

        this.init();
    }

    /**
     * åˆå§‹åŒ–ç›‘æ§å™¨
     */
    async init() {
        try {
            console.log('ğŸŠ åˆå§‹åŒ–æ± çˆ¬è™«ç›‘æ§å™¨');

            // åŠ è½½Socket.IOåº“
            await this.loadSocketIO();

            // æ¸²æŸ“UI
            this.render();

            // è¿æ¥Socket.IO
            if (this.options.autoConnect) {
                this.connect();
            }

            // å¯åŠ¨æ—¶é—´æ›´æ–°å®šæ—¶å™¨
            this.startTimeUpdateTimer();

            console.log('âœ… æ± çˆ¬è™«ç›‘æ§å™¨åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('âŒ æ± çˆ¬è™«ç›‘æ§å™¨åˆå§‹åŒ–å¤±è´¥:', error);
        }
    }

    /**
     * åŠ¨æ€åŠ è½½Socket.IOåº“
     */
    async loadSocketIO() {
        return new Promise((resolve, reject) => {
            // æ£€æŸ¥æ˜¯å¦å·²ç»åŠ è½½
            if (window.io) {
                resolve();
                return;
            }

            // åŠ¨æ€åŠ è½½Socket.IOè„šæœ¬
            const script = document.createElement('script');
            script.src = '/socket.io/socket.io.js';
            script.onload = () => {
                console.log('âœ… Socket.IOåº“åŠ è½½å®Œæˆ');
                resolve();
            };
            script.onerror = () => {
                console.error('âŒ Socket.IOåº“åŠ è½½å¤±è´¥');
                reject(new Error('Socket.IOåº“åŠ è½½å¤±è´¥'));
            };
            document.head.appendChild(script);
        });
    }

    /**
     * è¿æ¥Socket.IOæœåŠ¡å™¨
     */
    connect() {
        try {
            console.log('ğŸ”Œ è¿æ¥Socket.IOæœåŠ¡å™¨...');

            this.socket = io('http://localhost:7000', {
                path: '/socket.io/',
                transports: ['websocket', 'polling'],
                timeout: 5000,
                reconnection: true,
                reconnectionAttempts: this.options.maxReconnectAttempts,
                reconnectionDelay: this.options.reconnectInterval
            });

            this.setupSocketEvents();
        } catch (error) {
            console.error('âŒ Socket.IOè¿æ¥å¤±è´¥:', error);
            this.updateConnectionStatus('error', 'è¿æ¥å¤±è´¥');
        }
    }

    /**
     * è®¾ç½®Socket.IOäº‹ä»¶ç›‘å¬
     */
    setupSocketEvents() {
        // è¿æ¥æˆåŠŸ
        this.socket.on('connect', () => {
            console.log('âœ… Socket.IOè¿æ¥æˆåŠŸ');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.updateConnectionStatus('connected', 'å·²è¿æ¥');

            // è®¢é˜…æ± çˆ¬è™«ç›‘æ§
            this.socket.emit('subscribe:pool-crawler', {
                clientId: this.generateClientId(),
                timestamp: Date.now()
            });
        });

        // è¿æ¥æ–­å¼€
        this.socket.on('disconnect', (reason) => {
            console.log('ğŸ”Œ Socket.IOè¿æ¥æ–­å¼€:', reason);
            this.isConnected = false;
            this.updateConnectionStatus('disconnected', 'è¿æ¥æ–­å¼€');
        });

        // è®¢é˜…ç¡®è®¤
        this.socket.on('subscribed:pool-crawler', (data) => {
            console.log('âœ… æ± çˆ¬è™«ç›‘æ§è®¢é˜…æˆåŠŸ:', data);
            this.updateConnectionStatus('subscribed', 'ç›‘æ§ä¸­');

            // è¯·æ±‚å½“å‰çŠ¶æ€
            this.requestCrawlerStatus();
        });

        // ğŸ”¥ æ± çˆ¬è™«çŠ¶æ€æ›´æ–°
        this.socket.on('pool-crawler:status-update', (data) => {
            console.log('ğŸ“Š æ”¶åˆ°æ± çˆ¬è™«çŠ¶æ€æ›´æ–°:', data);
            this.handleStatusUpdate(data);
        });

        // ğŸ”¥ æ± å‘ç°é€šçŸ¥
        this.socket.on('pool-crawler:pools-discovered', (data) => {
            console.log('ğŸŠ æ”¶åˆ°æ± å‘ç°é€šçŸ¥:', data);
            this.handlePoolsDiscovered(data);
        });

        // ğŸ”¥ åˆæ ¼æ± é€šçŸ¥
        this.socket.on('pool-crawler:pools-qualified', (data) => {
            console.log('âœ… æ”¶åˆ°åˆæ ¼æ± é€šçŸ¥:', data);
            this.handlePoolsQualified(data);
        });

        // ğŸ”¥ è¿‡æ»¤å™¨é…ç½®æ›´æ–°
        this.socket.on('pool-crawler:filters-updated', (data) => {
            console.log('ğŸ”§ æ”¶åˆ°è¿‡æ»¤å™¨é…ç½®æ›´æ–°:', data);
            this.handleFiltersUpdated(data);
        });

        // ğŸ”¥ çˆ¬è™«é”™è¯¯é€šçŸ¥
        this.socket.on('pool-crawler:error', (data) => {
            console.log('âŒ æ”¶åˆ°çˆ¬è™«é”™è¯¯é€šçŸ¥:', data);
            this.handleCrawlerError(data);
        });

        // è¿æ¥é”™è¯¯
        this.socket.on('connect_error', (error) => {
            console.error('âŒ Socket.IOè¿æ¥é”™è¯¯:', error);
            this.reconnectAttempts++;
            this.updateConnectionStatus('error', `è¿æ¥é”™è¯¯ (${this.reconnectAttempts}/${this.options.maxReconnectAttempts})`);
        });

        // é‡è¿
        this.socket.on('reconnect', (attemptNumber) => {
            console.log(`ğŸ”„ Socket.IOé‡è¿æˆåŠŸ (ç¬¬${attemptNumber}æ¬¡å°è¯•)`);
            this.isConnected = true;
            this.updateConnectionStatus('reconnected', 'é‡è¿æˆåŠŸ');
        });

        // é‡è¿å¤±è´¥
        this.socket.on('reconnect_failed', () => {
            console.error('âŒ Socket.IOé‡è¿å¤±è´¥');
            this.updateConnectionStatus('failed', 'é‡è¿å¤±è´¥');
        });
    }

    /**
     * å¤„ç†çŠ¶æ€æ›´æ–°
     */
    handleStatusUpdate(socketData) {
        const { data } = socketData;

        // æ›´æ–°çˆ¬è™«çŠ¶æ€
        Object.assign(this.crawlerStatus, data);

        // æ›´æ–°UI
        this.updateStatusDisplay();
        this.updateLastUpdateTime();

        // æ˜¾ç¤ºé€šçŸ¥
        if (data.isRunning !== undefined) {
            this.showNotification(
                `æ± çˆ¬è™«${data.isRunning ? 'å·²å¯åŠ¨' : 'å·²åœæ­¢'}`,
                data.isRunning ? 'success' : 'info'
            );
        }
    }

    /**
     * å¤„ç†æ± å‘ç°é€šçŸ¥
     */
    handlePoolsDiscovered(socketData) {
        const { data } = socketData;

        if (data.pools && Array.isArray(data.pools)) {
            data.pools.forEach(pool => {
                this.discoveredPools.set(pool.poolAddress, pool);
            });

            // æ›´æ–°å‘ç°æ± è¡¨æ ¼
            this.updatePoolsTable();

            // æ˜¾ç¤ºé€šçŸ¥
            this.showNotification(
                `å‘ç° ${data.pools.length} ä¸ªæ–°æ± `,
                'info'
            );
        }
    }

    /**
     * å¤„ç†åˆæ ¼æ± é€šçŸ¥
     */
    handlePoolsQualified(socketData) {
        const { data } = socketData;

        if (data.pools && Array.isArray(data.pools)) {
            data.pools.forEach(pool => {
                this.qualifiedPools.set(pool.poolAddress, pool);
            });

            // æ›´æ–°åˆæ ¼æ± è¡¨æ ¼
            this.updateQualifiedPoolsTable();

            // æ˜¾ç¤ºé€šçŸ¥
            this.showNotification(
                `å‘ç° ${data.pools.length} ä¸ªåˆæ ¼æ± ï¼`,
                'success'
            );
        }
    }

    /**
     * å¤„ç†è¿‡æ»¤å™¨é…ç½®æ›´æ–°
     */
    handleFiltersUpdated(socketData) {
        const { data } = socketData;

        this.crawlerConfig = data;

        // æ›´æ–°è¿‡æ»¤å™¨é…ç½®æ˜¾ç¤º
        this.updateFilterDisplay();

        // æ˜¾ç¤ºé€šçŸ¥
        this.showNotification('è¿‡æ»¤å™¨é…ç½®å·²æ›´æ–°', 'info');
    }

    /**
     * å¤„ç†çˆ¬è™«é”™è¯¯é€šçŸ¥
     */
    handleCrawlerError(socketData) {
        const { data } = socketData;

        // æ›´æ–°é”™è¯¯è®¡æ•°
        this.crawlerStatus.errorCount++;

        // æ˜¾ç¤ºé”™è¯¯é€šçŸ¥
        this.showNotification(
            `çˆ¬è™«é”™è¯¯: ${data.error}`,
            'error'
        );

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        this.updateStatusDisplay();
    }

    /**
     * è¯·æ±‚çˆ¬è™«çŠ¶æ€
     */
    async requestCrawlerStatus() {
        try {
            const response = await fetch('/api/monitoring/crawler/status');
            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    this.crawlerStatus = result.data;
                    this.updateStatusDisplay();
                }
            }
        } catch (error) {
            console.error('è·å–çˆ¬è™«çŠ¶æ€å¤±è´¥:', error);
        }
    }

    /**
     * æ¸²æŸ“UI
     */
    render() {
        if (!this.container) return;

        this.container.innerHTML = `
            <div class="pool-crawler-monitor">
                <!-- è¿æ¥çŠ¶æ€ -->
                <div class="status-bar">
                    <div class="connection-status">
                        <span class="status-indicator" id="connectionStatus"></span>
                        <span class="status-text" id="connectionText">è¿æ¥ä¸­...</span>
                    </div>
                    <div class="last-update">
                        æœ€åæ›´æ–°: <span id="lastUpdateTime">--</span>
                    </div>
                </div>

                <!-- çˆ¬è™«çŠ¶æ€é¢æ¿ -->
                <div class="crawler-status-panel">
                    <h3>ğŸŠ æ± çˆ¬è™«çŠ¶æ€</h3>
                    <div class="status-grid">
                        <div class="status-item">
                            <label>è¿è¡ŒçŠ¶æ€:</label>
                            <span id="crawlerRunning" class="status-value">--</span>
                        </div>
                        <div class="status-item">
                            <label>ä¸‹æ¬¡çˆ¬å–:</label>
                            <span id="nextCrawlTime" class="status-value">--</span>
                        </div>
                        <div class="status-item">
                            <label>ä»Šæ—¥å‘ç°:</label>
                            <span id="dailyDiscoveries" class="status-value">--</span>
                        </div>
                        <div class="status-item">
                            <label>åˆæ ¼æ± æ•°:</label>
                            <span id="qualifiedCount" class="status-value">--</span>
                        </div>
                    </div>
                    <div class="crawler-controls">
                        <button id="startCrawler" class="btn btn-success">å¯åŠ¨çˆ¬è™«</button>
                        <button id="stopCrawler" class="btn btn-danger">åœæ­¢çˆ¬è™«</button>
                        <button id="refreshStatus" class="btn btn-info">åˆ·æ–°çŠ¶æ€</button>
                    </div>
                </div>

                <!-- è¿‡æ»¤å™¨é…ç½® -->
                <div class="filter-panel">
                    <h3>ğŸ”§ è¿‡æ»¤å™¨é…ç½®</h3>
                    <div class="filter-form" id="filterForm">
                        <!-- è¿‡æ»¤å™¨é…ç½®è¡¨å•å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>

                <!-- å‘ç°çš„æ±  -->
                <div class="pools-panel">
                    <h3>ğŸŠ å‘ç°çš„æ± </h3>
                    <div class="pools-table-container">
                        <table class="pools-table" id="poolsTable">
                            <thead>
                                <tr>
                                    <th>æ± åœ°å€</th>
                                    <th>ä»£å¸å¯¹</th>
                                    <th>Meteorè¯„åˆ†</th>
                                    <th>æµåŠ¨æ€§</th>
                                    <th>æ± é¾„</th>
                                    <th>24hæ¶¨è·Œ</th>
                                    <th>24hæˆäº¤é‡</th>
                                    <th>çŠ¶æ€</th>
                                    <th>æ“ä½œ</th>
                                </tr>
                            </thead>
                            <tbody id="poolsTableBody">
                                <!-- æ± æ•°æ®å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- åˆæ ¼æ± æ¨è -->
                <div class="qualified-pools-panel">
                    <h3>âœ… åˆæ ¼æ± æ¨è</h3>
                    <div class="qualified-pools-container" id="qualifiedPoolsContainer">
                        <!-- åˆæ ¼æ± æ¨èå°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>

                <!-- é€šçŸ¥åŒºåŸŸ -->
                <div class="notification-container" id="notificationContainer">
                    <!-- é€šçŸ¥å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        `;

        this.isRendered = true;
        this.bindEvents();
    }

    /**
     * ç»‘å®šäº‹ä»¶
     */
    bindEvents() {
        // çˆ¬è™«æ§åˆ¶æŒ‰é’®
        document.getElementById('startCrawler')?.addEventListener('click', () => this.startCrawler());
        document.getElementById('stopCrawler')?.addEventListener('click', () => this.stopCrawler());
        document.getElementById('refreshStatus')?.addEventListener('click', () => this.requestCrawlerStatus());
    }

    /**
     * å¯åŠ¨çˆ¬è™«
     */
    async startCrawler() {
        try {
            const response = await fetch('/api/monitoring/crawler/start', {
                method: 'POST'
            });
            const result = await response.json();

            if (result.success) {
                this.showNotification('çˆ¬è™«å¯åŠ¨æˆåŠŸ', 'success');
            } else {
                this.showNotification(`å¯åŠ¨å¤±è´¥: ${result.message}`, 'error');
            }
        } catch (error) {
            console.error('å¯åŠ¨çˆ¬è™«å¤±è´¥:', error);
            this.showNotification('å¯åŠ¨çˆ¬è™«å¤±è´¥', 'error');
        }
    }

    /**
     * åœæ­¢çˆ¬è™«
     */
    async stopCrawler() {
        try {
            const response = await fetch('/api/monitoring/crawler/stop', {
                method: 'POST'
            });
            const result = await response.json();

            if (result.success) {
                this.showNotification('çˆ¬è™«åœæ­¢æˆåŠŸ', 'success');
            } else {
                this.showNotification(`åœæ­¢å¤±è´¥: ${result.message}`, 'error');
            }
        } catch (error) {
            console.error('åœæ­¢çˆ¬è™«å¤±è´¥:', error);
            this.showNotification('åœæ­¢çˆ¬è™«å¤±è´¥', 'error');
        }
    }

    /**
     * æ›´æ–°çŠ¶æ€æ˜¾ç¤º
     */
    updateStatusDisplay() {
        const runningElement = document.getElementById('crawlerRunning');
        const nextCrawlElement = document.getElementById('nextCrawlTime');
        const dailyElement = document.getElementById('dailyDiscoveries');
        const qualifiedElement = document.getElementById('qualifiedCount');

        if (runningElement) {
            runningElement.textContent = this.crawlerStatus.isRunning ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢';
            runningElement.className = `status-value ${this.crawlerStatus.isRunning ? 'running' : 'stopped'}`;
        }

        if (nextCrawlElement) {
            nextCrawlElement.textContent = this.crawlerStatus.nextCrawlTime
                ? this.formatTime(this.crawlerStatus.nextCrawlTime)
                : '--';
        }

        if (dailyElement) {
            dailyElement.textContent = this.crawlerStatus.dailyDiscoveries || 0;
        }

        if (qualifiedElement) {
            qualifiedElement.textContent = this.crawlerStatus.qualifiedPools || 0;
        }
    }

    /**
     * æ›´æ–°è¿‡æ»¤å™¨æ˜¾ç¤º
     */
    updateFilterDisplay() {
        // TODO: å®ç°è¿‡æ»¤å™¨é…ç½®æ˜¾ç¤º
        console.log('æ›´æ–°è¿‡æ»¤å™¨æ˜¾ç¤º', this.crawlerConfig);
    }

    /**
     * æ›´æ–°æ± è¡¨æ ¼
     */
    updatePoolsTable() {
        const tableBody = document.getElementById('poolsTableBody');
        if (!tableBody) return;

        const pools = Array.from(this.discoveredPools.values());

        tableBody.innerHTML = pools.map(pool => `
            <tr>
                <td>${this.formatAddress(pool.poolAddress)}</td>
                <td>${pool.tokenPair}</td>
                <td>${pool.meteorScore}</td>
                <td>${this.formatCurrency(pool.liquidity)}</td>
                <td>${pool.age}</td>
                <td class="${pool.priceChange24h >= 0 ? 'positive' : 'negative'}">
                    ${this.formatPercent(pool.priceChange24h)}
                </td>
                <td>${this.formatCurrency(pool.volume24h)}</td>
                <td>
                    <span class="status-badge ${pool.qualified ? 'qualified' : 'pending'}">
                        ${pool.qualified ? 'åˆæ ¼' : 'å¾…æ£€æŸ¥'}
                    </span>
                </td>
                <td>
                    <button class="btn btn-sm btn-primary" onclick="this.createStrategy('${pool.poolAddress}')">
                        åˆ›å»ºç­–ç•¥
                    </button>
                </td>
            </tr>
        `).join('');
    }

    /**
     * æ›´æ–°åˆæ ¼æ± è¡¨æ ¼
     */
    updateQualifiedPoolsTable() {
        const container = document.getElementById('qualifiedPoolsContainer');
        if (!container) return;

        const qualifiedPools = Array.from(this.qualifiedPools.values());

        container.innerHTML = qualifiedPools.map(pool => `
            <div class="qualified-pool-card">
                <div class="pool-info">
                    <h4>${pool.tokenPair}</h4>
                    <p>Meteorè¯„åˆ†: ${pool.meteorScore}</p>
                    <p>æµåŠ¨æ€§: ${this.formatCurrency(pool.liquidity)}</p>
                    <p>24hæ¶¨è·Œ: ${this.formatPercent(pool.priceChange24h)}</p>
                </div>
                <div class="pool-actions">
                    <button class="btn btn-primary" onclick="this.createStrategy('${pool.poolAddress}')">
                        åˆ›å»ºç­–ç•¥
                    </button>
                </div>
            </div>
        `).join('');
    }

    /**
     * åˆ›å»ºç­–ç•¥
     */
    createStrategy(poolAddress) {
        // TODO: å®ç°ç­–ç•¥åˆ›å»ºé€»è¾‘
        console.log('åˆ›å»ºç­–ç•¥:', poolAddress);
        this.showNotification('ç­–ç•¥åˆ›å»ºåŠŸèƒ½å¼€å‘ä¸­...', 'info');
    }

    /**
     * æ›´æ–°è¿æ¥çŠ¶æ€
     */
    updateConnectionStatus(status, text) {
        const statusElement = document.getElementById('connectionStatus');
        const textElement = document.getElementById('connectionText');

        if (statusElement) {
            statusElement.className = `status-indicator ${status}`;
        }

        if (textElement) {
            textElement.textContent = text;
        }
    }

    /**
     * æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
     */
    updateLastUpdateTime() {
        this.lastUpdateTime = Date.now();
        const element = document.getElementById('lastUpdateTime');
        if (element) {
            element.textContent = this.formatTime(this.lastUpdateTime);
        }
    }

    /**
     * æ˜¾ç¤ºé€šçŸ¥
     */
    showNotification(message, type = 'info') {
        const container = document.getElementById('notificationContainer');
        if (!container) return;

        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <span class="notification-message">${message}</span>
                <button class="notification-close" onclick="this.parentElement.parentElement.remove()">Ã—</button>
            </div>
        `;

        container.appendChild(notification);

        // è‡ªåŠ¨ç§»é™¤é€šçŸ¥
        setTimeout(() => {
            if (notification.parentElement) {
                notification.parentElement.removeChild(notification);
            }
        }, 5000);
    }

    /**
     * å¯åŠ¨æ—¶é—´æ›´æ–°å®šæ—¶å™¨
     */
    startTimeUpdateTimer() {
        setInterval(() => {
            this.updateLastUpdateTime();
        }, 1000);
    }

    /**
     * ç”Ÿæˆå®¢æˆ·ç«¯ID
     */
    generateClientId() {
        return `pool-crawler-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * æ ¼å¼åŒ–æ—¶é—´
     */
    formatTime(timestamp) {
        if (!timestamp) return '--';
        return new Date(timestamp).toLocaleString('zh-CN');
    }

    /**
     * æ ¼å¼åŒ–è´§å¸
     */
    formatCurrency(amount) {
        if (!amount) return '--';
        return new Intl.NumberFormat('zh-CN', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
        }).format(amount);
    }

    /**
     * æ ¼å¼åŒ–ç™¾åˆ†æ¯”
     */
    formatPercent(value) {
        if (value === null || value === undefined) return '--';
        return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
    }

    /**
     * æ ¼å¼åŒ–åœ°å€
     */
    formatAddress(address) {
        if (!address) return '--';
        return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    /**
     * é”€æ¯ç›‘æ§å™¨
     */
    destroy() {
        if (this.socket) {
            this.socket.emit('unsubscribe:pool-crawler');
            this.socket.disconnect();
        }

        if (this.container) {
            this.container.innerHTML = '';
        }
    }
}

// å…¨å±€æš´éœ²
window.PoolCrawlerMonitor = PoolCrawlerMonitor; 