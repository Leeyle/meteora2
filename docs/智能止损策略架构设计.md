核心组件分离
📦 策略系统架构
├── 🎯 策略执行器 (StrategyExecutor)
│   ├── 数据收集与整合
│   ├── 决策引擎调用
│   ├── 执行动作管理
│   └── 状态监控与日志
│
├── 🧠 智能决策引擎 (StopLossDecisionEngine)
│   ├── 风险评估算法
│   ├── 止损条件判断
│   ├── 决策逻辑处理
│   └── 建议输出生成
│
└── 📊 数据适配器 (DataAdapter)
    ├── 价格数据获取
    ├── 收益数据计算
    ├── 流动性数据分析
    └── 数据格式标准化

    具体实现方案
1. 策略执行器 (主控脚本)
// 职责：协调整个策略流程
class StrategyExecutor {
    // 🔄 主要工作流程
    async executeStrategy() {
        // 1. 收集所有必要数据
        const marketData = await this.collectMarketData();
        
        // 2. 调用决策引擎
        const decision = await this.decisionEngine.analyze(marketData);
        
        // 3. 根据决策执行动作
        await this.executeDecision(decision);
        
        // 4. 记录和监控
        await this.logAndMonitor(decision);
    }
}

2. 智能决策引擎 (纯逻辑组件)
// 职责：纯粹的决策逻辑，无外部依赖
class StopLossDecisionEngine {
    // 🧠 核心决策方法
    analyze(marketData: MarketData): StopLossDecision {
        // 1. 风险评估
        const riskScore = this.calculateRiskScore(marketData);
        
        // 2. 止损条件判断
        const shouldStopLoss = this.evaluateStopLossConditions(marketData, riskScore);
        
        // 3. 生成决策建议
        return this.generateDecision(shouldStopLoss, riskScore, marketData);
    }
    
    // 不包含任何数据获取逻辑，只处理传入的数据
}

3. 数据适配器 (数据桥接)
// 职责：将各种服务的数据转换为决策引擎需要的格式
class DataAdapter {
    async collectMarketData(): Promise<MarketData> {
        // 从各个服务收集数据并标准化
        const priceData = await this.positionAnalyticsService.getCurrentPrice();
        const yieldData = await this.positionAnalyticsService.getYieldStatistics();
        const lossData = await this.positionAnalyticsService.getPositionLossAnalysis();
        
        // 转换为标准格式
        return this.formatMarketData(priceData, yieldData, lossData);
    }
}

📋 数据流设计
标准化数据接口
// 决策引擎的输入数据格式
interface MarketData {
    // 价格相关
    currentPrice: number;
    priceHistory: PricePoint[];
    priceVolatility: number;
    priceDropPercentage: number;
    
    // 收益相关
    totalReturn: number;
    yieldRate: number;
    yieldTrend: 'increasing' | 'decreasing' | 'stable';
    yieldGrowthRate: number;
    
    // 头寸相关
    positionValue: number;
    initialInvestment: number;
    netPnL: number;
    netPnLPercentage: number;
    
    // 流动性相关
    inRangePercentage: number;
    liquidityHealth: number;
    activeBinDistance: number;
    
    // 时间相关
    holdingDuration: number;
    lastUpdateTime: number;
}

// 决策引擎的输出格式
interface StopLossDecision {
    action: 'HOLD' | 'PARTIAL_EXIT' | 'FULL_EXIT' | 'ALERT';
    confidence: number; // 0-100
    riskScore: number; // 0-100
    reasoning: string[];
    suggestedExitPercentage?: number;
    urgency: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    nextEvaluationTime: number;
}

🔄 运行模式设计
1. 定时策略模式
// 主策略脚本 - 定时执行
class TimedStopLossStrategy {
    async start() {
        setInterval(async () => {
            try {
                await this.strategyExecutor.executeStrategy();
            } catch (error) {
                await this.handleError(error);
            }
        }, this.config.evaluationInterval);
    }
}

2. 事件驱动模式
// 基于价格变化或收益变化触发
class EventDrivenStopLossStrategy {
    async initialize() {
        // 监听价格变化事件
        this.priceMonitor.on('priceChange', async (priceData) => {
            if (this.shouldEvaluate(priceData)) {
                await this.strategyExecutor.executeStrategy();
            }
        });
    }
}

📁 文件结构建议
strategies/
├── stop-loss/
│   ├── StopLossStrategy.ts           # 主策略执行器
│   ├── StopLossDecisionEngine.ts     # 决策引擎 (纯逻辑)
│   ├── StopLossDataAdapter.ts        # 数据适配器
│   ├── StopLossExecutor.ts           # 执行器 (处理实际止损操作)
│   └── types/
│       ├── StopLossTypes.ts          # 类型定义
│       └── StopLossConfig.ts         # 配置接口
│
├── shared/
│   ├── StrategyBase.ts               # 策略基类
│   ├── DecisionEngineBase.ts         # 决策引擎基类
│   └── DataAdapterBase.ts            # 数据适配器基类
│
└── utils/
    ├── RiskCalculator.ts             # 风险计算工具
    ├── TrendAnalyzer.ts              # 趋势分析工具
    └── PerformanceTracker.ts         # 性能跟踪工具

    🎯 优势分析
1. 职责分离清晰
策略执行器：负责协调和执行
决策引擎：专注于逻辑判断
数据适配器：处理数据转换
2. 可测试性强
决策引擎可以独立单元测试
可以用模拟数据测试各种场景
易于验证决策逻辑的正确性
3. 可扩展性好
可以轻松添加新的决策因子
可以替换不同的决策算法
可以适配不同的数据源
4. 可维护性高
逻辑集中在决策引擎中
数据处理与业务逻辑分离
易于调试和优化
🚀 实施步骤
第一步：设计并实现标准化数据接口
第二步：开发决策引擎的核心逻辑
第三步：实现数据适配器
第四步：开发策略执行器
第五步：集成测试和优化
这样的架构设计让决策引擎专注于"判断"，而策略执行器负责"协调"，数据适配器负责"桥接"。你觉得这个方案如何？